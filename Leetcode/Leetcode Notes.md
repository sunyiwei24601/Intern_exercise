## 20.Valid Parenthesis

1. 这道题目的原意是,括号按照语法成对出现,不能一个内部的括号还没结束,外面的括号就已经合上了.
2. 使用栈的方式,左括号则入栈,右括号则检查和栈顶的关系.
3. 用Python做题的时候,需要注意关于类的两个规则:
   1. 不在__init__里面声明是self.xxx的变量,都会被认为是类变量,会被不同的对象共享
   2. 一旦某一个对象对类变量进行修改,如a.num = 2,那么该对象就会自动生成一个实例变量,覆盖之前的类变量,而其他对象的类变量num并不会改变数值

## 21.Merge Two Sorted Lists

1. 注意空链表的情况
2. 设置一个初始的start_node结点,然后返回这个头结点
3. 下次记得NodeListsTools方便测试

## 22.Generate Parenthesis

1. 简单的递归backtrack技巧

2. 递归的关键在于,终点是符号已经用完,每次左括号都至少应该大于等于右括号的数量,否则就会出错

3. 所有可能性应该为C(2n, n) /(n+1)种,也就是空间复杂度,这刚好是一个卡特兰数的定义,详细的论证过程在此https://blog.csdn.net/a2796749/article/details/47439257

   简单进行证明就是,在2n个位置里选n个数为0,n个数为1,从左到右扫描,0出现的个数不能大于1出现的个数

   总的可能性是C(2n,n), 减去错误的可能性即可

   对于任何一种错误的可能性,必然存在前2m+1个数中有m+1个0和m个1, 其后的数字必有n-m-1个0和n-m个1,如果我们将后面的1,0反转,我们就可以得到一个总数为n+1个0,n-1个1的数列,也就刚好是C(2n,n+1)的排列组合

   C(2n,n)-C(2n,n+1) = C(2n,n)/(n+1)

   

## 23. Merge K Sorted Lists

1. 采用分治算法,总的时间复杂度为nk,n为总的数据量,k为链表数量

## 25.Reverse Nodes in K Groups

1. 比较费脑子，考验耐心的一道题
2. 先判定k=1，head为空或1的情况，直接原路返回
3. 然后统计链表的长度count
4. i从0到k，逐渐增加，如果为0，则说明是反转的末尾，记为tail
5. 记住上一个group的末尾为p， 每次p都指向最新的节点，也就记录下了前一个节点
6. q和temp轮换记录下一个节点，然后将其指向p指向的结点，也就是上一个节点，这个用p指向而不是新建一个变量，可以更优雅地表示，因为到了最后p就一定会指向反转后的第一个节点
7. 最后将p标记为tail，减少链表的长度，开始下一轮循环，如果链表长度小于k，就可将后续节点直接连接到p的后面

## 26.Remove Duplicates From Sorted Array

1. 这个实施起来可能比想象中的复杂一点,因为涉及到引用变量nums,对于它的修改,remove会直接变化,赋值修改则会产生另一个一样的变量,但是id却不同,不清楚该系统对于引用变量的具体实现方式,所以不太了解
2. 这个算法还是应该写一个C++或者Java的版本比较好

## 28. Implement strStr()

1. 以字符串的每一个字符为开始,前n位是否有与needle相同的字符串,时间复杂度是nm
2. 判断不符合之后,下一个字符串要重新从开始判定,否则就会漏掉"Mississippi"和"issip"这样的问题
3. 考虑临界位置,当剩余字符数量少于needle长度时,不用再判定

## 29.Divide Two Integer

1. 这里主要是一个实现二进制的除法的操作
2. 注意三个不停变换的对象, 第一个是 divisor,按照除法,每次都要找到刚好小于dividend的那个除数的整倍数,然后减去它,得到新的dividend. 第二个是 count,也就是位数, 每次寻找最大divisor的时候,都要通过count来记录具体的倍数.
3. 剩余dividend刚好等于divisor的时候,也要考虑进去
4. 最后还要考虑一下正数和负数会有不同的outrange的情况

## 31.Next Permutation

1. 其实就是相同的数字组合下,找出下一个更大的数字
2. 比如13542
   1. 首先从右往左看,找到第一个不是逐渐增大的数字,也就是3
   2. 然后寻找3左边刚好大于3的数字,因为3是第一个减小的数字,所以必然会有比其大的数字,找到这个数字,也就是4,将3和4位置调换,得到14532
   3. 由于3是调换到刚好大于它的数字上,所以右边的部分仍旧是降序排列,我们只需要将其反转就可以得到一个最小的数字了

## 34.Search in Rotated Array

1. 一个很好的测试二分查找的题目
2. 比较简单的思路是，如果start小于end，则说明整个序列都在递增，就可以直接与中间比较，看是找左边还是右边，如果start>end,则情况尚不确定，要两个都找
3. 看上去终止条件是start刚好为target，另一个终止条件是，start=end，说明已经最小了

## 35.Find First and Last Position of Element in Sorted Array

1. 那个。。。这是个有序的数列
2. 另外，先查左边来确定有没有，再查右边，用两个指针来分别表示最小和最大的位置，先找左边，再找右边
3. 这个我必须吹一波，寻找左边的函数可以和右边的函数用同一个，如果是左边的话，则中间相等变最大的位置为中间，如果是右边，中间相等就变最小位置为中间

## 50.Power(x,n)

1. 二分法进行计算,这样只用计算logn次,而且用记忆的方法,可能logn也不需要

## 49.Group Anagrams

1. 我们可以将每个数tuple化,然后降序排列,来判断是否是同一组,用字典来实现,可以自动hash化比较,效率更高
2. 另外我们也可以将26个字母转化为一个序列,每一个位置上的数字代表字母出现的频率,这样就少了排序的过程,时间复杂度上少很多.
3. collections.defaultdict(list)调用collections包的这个函数,可以对字典进行初始化

## 54.Spiral Matrix

1. 设定一个存储是否已经被访问过的库，每一次都以向右、下、左、上的顺序一路走到尽头或者库中显示已经被走过的数字
2. 也可以使用yield，每一个右下左上的循环就是一个圈，算好这个圈的四个角的位置来进行循环，少了存储库的过程
3. 此外，python的函数是不存在引用参数的，只能以修改类或者对象的方式来进行变化
4. 设置初始数组的时候不能`[[1] x 3] x 5`这样的操作，里面五个数组都是同一个对象，要变一起变的，还是用短的for循环比较好

## 55. Jump Game

1. 几乎是一个非常好的动态规划的题目，同时又有一个非常简单明了的解法
2. 一个普遍的动态规划的思路是，用一个memo变量记录下每一个位置能否到达，然后尝试不同的从起点出发的可能性，如果遇到已经记录可以达到的位置，则返回True，如果遇到Unknown就进一步探索，如果全是False，则返回也是False
3. 但是我们也可以采用一个反向的算法，从右往左开始寻找，依次查看每一个位置往右num[i]个位置，有没有记录为True的，如果有就可以标记为True，否则False，最后倒推到第一个
4. 但是这个反向算法也可以更加简化，我们不用调查往右num[i]个位置每一个有没有，因为显然，只要最左边的能到达，其他的也就能到达。所以我们只需要保存最左边一个能到达的点的位置，每次用i+num[i]和它比较，能到达就可以更新这个最左点
5. 在时间复杂度上有很大的差别，前两者都是O(n^2)，n个数据，它本身的跳跃范围最大也可能为n。 而最后一种算法只需要O（n）的复杂度，有着很大的优势。这告诉我们，在想出比较好的反向或者动态规划算法后，是否有什么位置需要简化的，是不是每一个数据都需要遍历，还是只用找到关键的即可。

## 74.Search a 2D Matrix

1. 由于是一个有序的矩阵,所以可以横向+竖向的二分搜索,从而使时间复杂度降为Log(n)+Log(m)
2. 二分查找的关键在于,判定mid是否是,如果判定了mid不是,则舍弃掉mid,剩下的搜索范围是(start, mid-1)和(mid+1, end),判定跳出循环的条件就是,start > end, 因为mid被去除了,且始终试图增加,如果搜索到最后剩下一个位置,是则是,不是则会出现start>end的情况,从而跳出.
3. 有时候不一定非要用递归,普通的while也挺好的



## 79. Word Search

1. 其实是一个简单的回溯法的题目,但是在编码过程中有点问题,一不小心就会超时
2. 从四个方向找寻找,可以采用directions的循环遍历方式,这样的好处是,一旦发现正确答案可以跳出循环,避免没有意义的搜索.
3. 另外我一开始想到了以memo矩阵存储所有节点是否访问过,但是python由于只能传数组对象,所以很容易被修改,不同的记录之间相互干涉. 我选了对所有数组进行复制拷贝,避免这种情况的发生,但是这样空间和时间占有量都过高了,并不合适. 
4. 一个可行的方案是,一次探索发现不行之后,直接将改变的memo还原,这样退回到最外层的函数时,memo会被复原回原状.如果探索成功的话直接返回就好了,不用在意这许多. 可以选择矩阵存储访问历史,也可以使用visited路径集合来进行判别,各有优劣,时间和空间的转换罢了.

## 134.Gas Station

1. 很有意思的一道题，并不考验算法，而是对于问题的分析和解析
2. 使用一个O（n）的时间复杂度，如果从i开始的一段距离并不能行得通，那么这一段距离内的所有点都不可能是解。判断有没有解只需要看总的cost 和 gas 谁大谁小就可以了。

## 135.Candy

1. 更有意思的一道题，就是有点困难，主要还是难在对于问题的分析和理解，又多种不同的解法

2. 首先是一个O(n)时间复杂度O(n)空间复杂度的解法，定一个candy列表，从左到右遍历，设置第一个为1，如果当前比左边大，则+1，没有则为1，以此类推，再从右边也来一次，将两个列表并列，每一个位置取较大的candy。 证明之所以能成立，如过 ai < a[i+1], 则从左边过一遍，c[i] < c[i+1],从右边过时，c[i] = 1，不会有影响, 如果ai > a[i+1], 则从左边过时， c[i+1] = 1, 从右边过时，c[i+1] =n, c[i] = n+1, 合并后的c[i]至少也会是n+1，不会有影响。

   这一方法也可以使用只用一个列表的解法，先从左往右，再从右往左时，和之前的数据多多比较就好了。

3. 但是它也有一个更加简单的解法，我们可以把整个数据看作一系列山峰，按照上坡依次增加，按照下坡逐渐减少，用new_slope old_slope来记录上下坡，在下坡转上坡的时候，说明山峰结束，沿途记录上坡和下坡的阶梯数量，就能算出走完这个上坡需要多少了，山顶自然是max（up，down）+1，但是要注意，每次下坡的最后一个格子都是另一个山峰的第一个起点，也就是1，这样每次计算都是都从1开始，而下坡则去掉一个1

## 240.Search a 2D Matrix II

1. 同之前那个矩阵搜索差不多，只不过这次不是找精准值，而是找一个区间，先是第一列最小值满足，然后是最后一列最大值满足
2. 最麻烦的部分在于找到刚好大于target的那一行，这里我选择了刚刚好大于等于target的那一行输出，但是寻找最后一行的时候就要比这个输出的结果+1，确保等于的情况可以被考虑到。

3. 好的我错了，还有更加方便的方法。先从最右边第一个开始找，如果比target小就往下，如果比target大就往左，这样就不用回头往右比，因为右边必定比右上方大，而正是因为右上方大于正上方，所以我们才会往下，所以只需要和现在所在的位置比，然后决定向左还是向下就好。